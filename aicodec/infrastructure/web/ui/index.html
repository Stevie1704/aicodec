<!DOCTYPE html>
<html lang="en">

<head>
 	<meta charset="UTF-8">
 	<meta name="viewport" content="width=device-width, initial-scale=1.0">
 	<title>AI Codec Review</title>
 	<style>
 	 	:root {
 	 	 	--bg-color: #1e1e1e;
 	 	 	--text-color: #d4d4d4;
 	 	 	--primary-color: #0e639c;
 	 	 	--border-color: #3c3c3c;
 	 	 	--card-bg: #252526;
 	 	 	--button-bg: #0e639c;
 	 	 	--button-hover-bg: #1177bb;
 	 	 	--button-disabled-bg: #5a5a5a;
 	 	 	--error-color: #f48771;
 	 	 	--secondary-button-bg: #3a3d41;
 	 	 	--secondary-button-hover-bg: #4a4d51;
 	 	}

 	 	body,
 	 	html {
 	 	 	margin: 0;
 	 	 	padding: 0;
 	 	 	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
 	 	 	background-color: var(--bg-color);
 	 	 	color: var(--text-color);
 	 	 	height: 100vh;
 	 	 	display: flex;
 	 	 	flex-direction: column;
 	 	 	overflow: hidden;
 	 	}

 	 	header {
 	 	 	padding: 10px 20px;
 	 	 	background-color: var(--card-bg);
 	 	 	border-bottom: 1px solid var(--border-color);
 	 	 	display: flex;
 	 	 	justify-content: space-between;
 	 	 	align-items: center;
 	 	 	flex-shrink: 0;
 	 	}

 	 	header h1 {
 	 	 	margin: 0;
 	 	 	font-size: 1.2em;
 	 	}

 	 	.header-buttons {
 	 	 	display: flex;
 	 	 	gap: 10px;
 	 	}

 	 	.container {
 	 	 	display: flex;
 	 	 	flex-grow: 1;
 	 	 	height: calc(100vh - 55px);
 	 	}

 	 	.sidebar {
 	 	 	width: 350px;
 	 	 	min-width: 300px;
 	 	 	background-color: var(--card-bg);
 	 	 	padding: 15px;
 	 	 	border-right: 1px solid var(--border-color);
 	 	 	display: flex;
 	 	 	flex-direction: column;
 	 	 	overflow-y: auto;
 	 	}

 	 	.main-content {
 	 	 	flex-grow: 1;
 	 	 	display: flex;
 	 	 	flex-direction: column;
 	 	}

 	 	.diff-header {
 	 	 	padding: 10px 15px;
 	 	 	background-color: #1e1e1e;
 	 	 	border-bottom: 1px solid var(--border-color);
 	 	 	font-family: Menlo, Monaco, 'Courier New', monospace;
 	 	 	font-size: 0.9em;
 	 	 	color: #cccccc;
 	 	}

 	 	#diff-editor {
 	 	 	flex-grow: 1;
 	 	 	width: 100%;
 	 	}

 	 	.card {
 	 	 	background-color: #2a2a2b;
 	 	 	border: 1px solid var(--border-color);
 	 	 	border-radius: 5px;
 	 	 	padding: 15px;
 	 	 	margin-bottom: 15px;
 	 	}

 	 	.card h3 {
 	 	 	margin-top: 0;
 	 	 	border-bottom: 1px solid var(--border-color);
 	 	 	padding-bottom: 8px;
 	 	}

 	 	#changes-list {
 	 	 	list-style-type: none;
 	 	 	padding: 0;
 	 	 	margin: 0;
 	 	 	overflow-y: auto;
 	 	 	flex-grow: 1;
 	 	}

 	 	#changes-list li {
 	 	 	padding: 8px;
 	 	 	border-radius: 3px;
 	 	 	cursor: pointer;
 	 	 	display: flex;
 	 	 	align-items: center;
 	 	 	margin-bottom: 5px;
 	 	}

 	 	#changes-list li:hover {
 	 	 	background-color: #333;
 	 	}

 	 	#changes-list li.selected {
 	 	 	background-color: var(--primary-color);
 	 	 	color: white;
 	 	}

 	 	.change-item-checkbox {
 	 	 	margin-right: 10px;
 	 	}

 	 	.action-tag {
 	 	 	font-size: 0.7em;
 	 	 	padding: 2px 5px;
 	 	 	border-radius: 3px;
 	 	 	color: white;
 	 	 	margin-left: auto;
 	 	 	font-weight: bold;
 	 	}

 	 	.action-CREATE {
 	 	 	background-color: #28a745;
 	 	}

 	 	.action-REPLACE {
 	 	 	background-color: #007bff;
 	 	}

 	 	.action-DELETE {
 	 	 	background-color: #dc3545;
 	 	}

 	 	.action-PATCH {
 	 	 	background-color: #ffc107; /* Warning yellow */
 	 	 	color: #1e1e1e;
 	 	}

 	 	.button {
 	 	 	background-color: var(--button-bg);
 	 	 	color: white;
 	 	 	border: none;
 	 	 	padding: 10px 15px;
 	 	 	border-radius: 5px;
 	 	 	cursor: pointer;
 	 	 	font-size: 1em;
 	 	 	transition: background-color 0.2s;
 	 	}

 	 	.button.secondary {
 	 	 	background-color: var(--secondary-button-bg);
 	 	}

 	 	.button:hover:not(:disabled) {
 	 	 	background-color: var(--button-hover-bg);
 	 	}

 	 	.button.secondary:hover:not(:disabled) {
 	 	 	background-color: var(--secondary-button-hover-bg);
 	 	}

 	 	.button:disabled {
 	 	 	background-color: var(--button-disabled-bg);
 	 	 	cursor: not-allowed;
 	 	}

 	 	#error-banner {
 	 	 	background-color: var(--error-color);
 	 	 	color: #1e1e1e;
 	 	 	padding: 5px 20px;
 	 	 	text-align: center;
 	 	 	font-weight: bold;
 	 	 	display: none;
 	 	}

 	 	.changes-header {
 	 	 	display: flex;
 	 	 	justify-content: space-between;
 	 	 	align-items: center;
 	 	 	margin-bottom: 10px;
 	 	}

 	 	#summary-text {
 	 	 	font-style: italic;
 	 	 	font-size: 0.9em;
 	 	}
 	</style>
</head>

<body>
 	<div id="error-banner">Auto-load failed. Check console for details.</div>
 	<header>
 	 	<h1 id="header-title">AI Codec Review UI</h1>
 	 	<div class="header-buttons">
 	 	 	<button id="save-button" class="button secondary" disabled>Save All Changes</button>
 	 	 	<button id="apply-button" class="button" disabled>Apply Selected Changes</button>
 	 	</div>
 	</header>
 	<div class="container">
 	 	<div class="sidebar">
 	 	 	<div class="card">
 	 	 	 	<h3>Summary</h3>
 	 	 	 	<div id="summary-text">Loading summary...</div>
 	 	 	</div>
 	 	 	<div class="card" style="flex-grow: 1; display: flex; flex-direction: column;">
 	 	 	 	<div class="changes-header">
 	 	 	 	 	<h3>Changes</h3>
 	 	 	 	 	<div>
 	 	 	 	 	 	<input type="checkbox" id="select-all-checkbox"> <label for="select-all-checkbox">Select
 	 	 	 	 	 	 	All</label>
 	 	 	 	 	</div>
 	 	 	 	</div>
 	 	 	 	<ul id="changes-list">

 	 	 	 	</ul>
 	 	 	</div>
 	 	</div>
 	 	<div class="main-content">
 	 	 	<div id="diff-header">Select a file to see the diff</div>
 	 	 	<div id="diff-editor"></div>
 	 	</div>
 	</div>

 	<script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.26.1/min/vs/loader.min.js"></script>
 	<script>
 	 	let diffEditor;
 	 	// allChangesData stores the *processed* data for the UI (e.g., patched content)
 	 	let allChangesData = { summary: '', changes: [], mode: 'apply' };
 	 	// rawChanges stores the *original* data from the server (e.g., the patch diff)
 	 	let rawChanges = [];
 	 	let currentModelListener = null;

 	 	document.addEventListener('DOMContentLoaded', () => {
 	 	 	require.config({ paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.26.1/min/vs' } });
 	 	 	require(['vs/editor/editor.main'], function () {
 	 	 	 	diffEditor = monaco.editor.createDiffEditor(document.getElementById('diff-editor'), {
 	 	 	 	 	theme: 'vs-dark',
 	 	 	 	 	automaticLayout: true
 	 	 	 	});
 	 	 	});

 	 	 	fetchChanges();

 	 	 	document.getElementById('select-all-checkbox').addEventListener('change', toggleSelectAll);
 	 	 	document.getElementById('save-button').addEventListener('click', saveChanges);
 	 	 	document.getElementById('apply-button').addEventListener('click', applyChanges);
 	 	});

 	 	function fetchChanges() {
 	 	 	fetch('/api/context')
 	 	 	 	.then(response => {
 	 	 	 	 	if (!response.ok) {
 	 	 	 	 	 	throw new Error(`HTTP error! status: ${response.status}`);
 	 	 	 	 	}
 	 	 	 	 	return response.json();
 	 	 	 	})
 	 	 	 	.then(data => {
 	 	 	 	 	// Store the data received from the server, which includes patched content
 	 	 	 	 	allChangesData = {
 	 	 	 	 	 	summary: data.summary || 'No summary provided.',
 	 	 	 	 	 	changes: data.changes || [], // This has 'proposed_content' already calculated
 	 	 	 	 	 	mode: data.mode || 'apply'
 	 	 	 	 	};
 	 	 	 	 	// Store a deep copy of the original raw changes for 'apply' and 'save' logic
 	 	 	 	 	rawChanges = JSON.parse(JSON.stringify(allChangesData.changes));

 	 	 	 	 	document.getElementById('summary-text').textContent = allChangesData.summary;
 	 	 	 	 	renderChangesList(allChangesData.changes);
 	 	 	 	 	updateUIText(allChangesData.mode);
 	 	 	 	 	// Disable save in revert mode OR if there are no changes to save.
 	 	 	 	 	document.getElementById('save-button').disabled = (allChangesData.mode === 'revert') || allChangesData.changes.length === 0;
 	 	 	 	})
 	 	 	 	.catch(error => {
 	 	 	 	 	console.error('Error fetching changes:', error);
 	 	 	 	 	document.getElementById('error-banner').style.display = 'block';
 	 	 	 	});
 	 	}

 	 	function updateUIText(mode) {
 	 	 	const headerTitle = document.getElementById('header-title');
 	 	 	const applyButton = document.getElementById('apply-button');

 	 	 	if (mode === 'revert') {
 	 	 	 	headerTitle.textContent = 'AI Codec Revert UI';
 	 	 	 	applyButton.textContent = 'Revert Selected Changes';
 	 	 	} else {
 	 	 	 	headerTitle.textContent = 'AI Codec Apply UI';
 	 	 	 	applyButton.textContent = 'Apply Selected Changes';
 	 	 	}
 	 	}

 	 	function renderChangesList(changes) {
 	 	 	const list = document.getElementById('changes-list');
 	 	 	list.innerHTML = '';
 	 	 	changes.forEach((change, index) => {
 	 	 	 	const li = document.createElement('li');
 	 	 	 	li.dataset.index = index;
 	 	 	 	li.onclick = () => displayDiff(index);

 	 	 	 	const checkbox = document.createElement('input');
 	 	 	 	checkbox.type = 'checkbox';
 	 	 	 	checkbox.className = 'change-item-checkbox';
 	 	 	 	checkbox.checked = true;
 	 	 	 	checkbox.onchange = () => {
 	 	 	 	 	updateApplyButtonState();
 	 	 	 	 	updateSelectAllState();
 	 	 	 	};
 	 	 	 	li.appendChild(checkbox);

 	 	 	 	const filePath = document.createElement('span');
 	 	 	 	filePath.textContent = change.filePath;
 	 	 	 	li.appendChild(filePath);

 	 	 	 	const tag = document.createElement('span');
 	 	 	 	tag.className = `action-tag action-${change.action}`;
 	 	 	 	tag.textContent = change.action;
 	 	 	 	li.appendChild(tag);

 	 	 	 	list.appendChild(li);
 	 	 	});
 	 	 	updateApplyButtonState();
 	 	 	updateSelectAllState();
 	 	}

 	 	function displayDiff(index) {
 	 	 	if (currentModelListener) {
 	 	 	 	currentModelListener.dispose();
 	 	 	}

 	 	 	document.querySelectorAll('#changes-list li').forEach(li => li.classList.remove('selected'));
 	 	 	document.querySelector(`#changes-list li[data-index='${index}']`).classList.add('selected');

 	 	 	const change = allChangesData.changes[index];

 	 	 	const originalContent = change.original_content;
 	 	 	const modifiedContent = change.proposed_content;

 	 	 	const originalModel = monaco.editor.createModel(originalContent, getLanguage(change.filePath));
 	 	 	const modifiedModel = monaco.editor.createModel(modifiedContent, getLanguage(change.filePath));

 	 	 	diffEditor.setModel({
 	 	 	 	original: originalModel,
 	 	 	 	modified: modifiedModel
 	 	 	});

 	 	 	diffEditor.getOriginalEditor().updateOptions({ readOnly: true });
 	 	 	// PATCH actions are read-only for now, as editing a patched file and saving
 	 	 	// it back as a patch is complex. Users can edit, and it will save as 'REPLACE'.
 	 	 	const isReadOnly = allChangesData.mode === 'revert';
 	 	 	diffEditor.getModifiedEditor().updateOptions({ readOnly: isReadOnly });

 	 	 	if (!isReadOnly) {
 	 	 	 	currentModelListener = modifiedModel.onDidChangeContent(() => {
 	 	 	 	 	// When content is edited, we store the new full content.
 	 	 	 	 	allChangesData.changes[index].proposed_content = modifiedModel.getValue();
 	 	 	 	 	// Mark that this change has been edited
 	 	 	 	 	allChangesData.changes[index].edited = true;
 	 	 	 	 	
 	 	 	 	 	// If it was a PATCH, it will now be applied/saved as a REPLACE.
 	 	 	 	 	// We update the tag in the UI to reflect this.
 	 	 	 	 	if (allChangesData.changes[index].action === 'PATCH') {
 	 	 	 	 	 	allChangesData.changes[index].action = 'REPLACE';
 	 	 	 	 	 	// Re-render the list to show the action change
 	 	 	 	 	 	renderChangesList(allChangesData.changes);
 	 	 	 	 	 	// Re-select the current item
 	 	 	 	 	 	document.querySelector(`#changes-list li[data-index='${index}']`).classList.add('selected');
 	 	 	 	 	}
 	 	 	 	});
 	 	 	}

 	 	 	document.getElementById('diff-header').textContent = `${change.filePath} - ${change.action}`;
 	 	}

 	 	function toggleSelectAll() {
 	 	 	const isChecked = document.getElementById('select-all-checkbox').checked;
 	 	 	document.querySelectorAll('.change-item-checkbox').forEach(cb => cb.checked = isChecked);
 	 	 	updateApplyButtonState();
 	 	}

 	 	function updateSelectAllState() {
 	 	 	const allCheckboxes = document.querySelectorAll('.change-item-checkbox');
 	 	 	const checkedCheckboxes = document.querySelectorAll('.change-item-checkbox:checked');
 	 	 	const selectAllCheckbox = document.getElementById('select-all-checkbox');

 	 	 	if (allCheckboxes.length > 0 && allCheckboxes.length === checkedCheckboxes.length) {
 	 	 	 	selectAllCheckbox.checked = true;
 	 	 	} else {
 	 	 	 	selectAllCheckbox.checked = false;
 	 	 	}
 	 	}

 	 	function updateApplyButtonState() {
 	 	 	const anyChecked = document.querySelector('.change-item-checkbox:checked') !== null;
 	 	 	document.getElementById('apply-button').disabled = !anyChecked;
 	 	}

 	 	function saveChanges() {
 	 	 	const saveButton = document.getElementById('save-button');
 	 	 	saveButton.disabled = true;
 	 	 	saveButton.textContent = 'Saving...';

 	 	 	// When saving, we must send back data in the *original* schema format.
 	 	 	// This means if a PATCH was *not* edited, we send the original patch diff.
 	 	 	// If it *was* edited, we send the full content and change the action to REPLACE.
 	 	 	const payload = {
 	 	 	 	summary: allChangesData.summary,
 	 	 	 	changes: allChangesData.changes.map((change, index) => {
 	 	 	 	 	const rawChange = rawChanges[index]; // Get the original, unmodified change
 	 	 	 	 	
 	 	 	 	 	if (change.edited) {
 	 	 	 	 	 	// File was edited in UI, send new content as REPLACE/CREATE
 	 	 	 	 	 	const newAction = (change.original_content === '') ? 'CREATE' : 'REPLACE';
 	 	 	 	 	 	return {
 	 	 	 	 	 	 	filePath: change.filePath,
 	 	 	 	 	 	 	action: newAction,
 	 	 	 	 	 	 	content: change.proposed_content // The new content from the editor
 	 	 	 	 	 	};
 	 	 	 	 	} else {
 	 	 	 	 	 	// File was not edited, send the *original* action and content
 	 	 	 	 	 	// Note: `rawChange.action` might be 'PATCH', but `allChangesData.changes[index].action`
 	 	 	 	 	 	// could be 'REPLACE' if the *server* detected it was a create.
 	 	 	 	 	 	// We trust the *server's processed action* (`change.action`) unless it was 'PATCH'.
 	 	 	 	 	 	
 	 	 	 	 	 	if (rawChange.action === 'PATCH' && change.action === 'PATCH') {
 	 	 	 	 	 	 	// It was a patch and remained a patch (wasn't edited, wasn't a create)
 	 	 	 	 	 	 	return {
 	 	 	 	 	 	 	 	filePath: rawChange.filePath,
 	 	 	 	 	 	 	 	action: 'PATCH',
 	 	 	 	 	 	 	 	content: rawChange.proposed_content // This is the raw patch diff
 	 	 	 	 	 	 	};
 	 	 	 	 	 	} else {
 	 	 	 	 	 	 	// It's a CREATE, REPLACE, or DELETE that wasn't edited.
 	 	 	 	 	 	 	return {
 	 	 	 	 	 	 	 	filePath: change.filePath,
 	 	 	 	 	 	 	 	action: change.action,
 	 	 	 	 	 	 	 	content: change.action === 'DELETE' ? '' : change.proposed_content
 	 	 	 	 	 	 	};
 	 	 	 	 	 	}
 	 	 	 	 	}
 	 	 	 	})
 	 	 	};

 	 	 	fetch('/api/save', {
 	 	 	 	method: 'POST',
 	 	 	 	headers: { 'Content-Type': 'application/json' },
 	 	 	 	body: JSON.stringify(payload)
 	 	 	})
 	 	 	 	.then(response => {
 	 	 	 	 	if (!response.ok) throw new Error('Save failed');
 	 	 	 	 	return response.json();
 	 	 	 	})
 	 	 	 	.then(() => {
 	 	 	 	 	saveButton.textContent = 'Saved!';
 	 	 	 	 	setTimeout(() => {
 	 	 	 	 	 	saveButton.textContent = 'Save All Changes';
 	 	 	 	 	 	// Reload the state from the server
 	 	 	 	 	 	fetchChanges();
 	 	 	 	 	}, 2000);
 	 	 	 	})
 	 	 	 	.catch(error => {
 	 	 	 	 	console.error('Error saving changes:', error);
 	 	 	 	 	saveButton.textContent = 'Save All Changes';
 	 	 	 	 	saveButton.disabled = (allChangesData.mode === 'revert');
 	 	 	 	 	alert('Failed to save changes.');
 	 	 	 	});
 	 	}

 	 	function applyChanges() {
 	 	 	const selectedChanges = [];
 	 	 	document.querySelectorAll('#changes-list li').forEach((li) => {
 	 	 	 	if (li.querySelector('.change-item-checkbox').checked) {
 	 	 	 	 	const index = parseInt(li.dataset.index, 10);
 	 	 	 	 	const change = allChangesData.changes[index]; // UI-state change
 	 	 	 	 	const rawChange = rawChanges[index]; // Original server change
 	 	 	 	 	
 	 	 	 	 	let action = change.action;
 	 	 	 	 	let content = change.proposed_content;

 	 	 	 	 	if (change.edited) {
 	 	 	 	 	 	// If edited, it's always REPLACE (or CREATE)
 	 	 	 	 	 	action = (change.original_content === '') ? 'CREATE' : 'REPLACE';
 	 	 	 	 	 	content = change.proposed_content;
 	 	 	 	 	} else if (rawChange.action === 'PATCH' && change.action === 'PATCH') {
 	 	 	 	 	 	// If not edited and was a patch, send the *original patch diff*
 	 	 	 	 	 	action = 'PATCH';
 	 	 	 	 	 	content = rawChange.proposed_content; // This is the patch diff
 	 	 	 	 	} else {
 	 	 	 	 	 	// Not edited, and not a patch (or was a patch that became a create)
 	 	 	 	 	 	action = change.action;
 	 	 	 	 	 	content = change.action === 'DELETE' ? '' : change.proposed_content;
 	 	 	 	 	}

 	 	 	 	 	selectedChanges.push({
 	 	 	 	 	 	filePath: change.filePath,
 	 	 	 	 	 	action: action,
 	 	 	 	 	 	content: content
 	 	 	 	 	});
 	 	 	 	}
 	 	 	});

 	 	 	const applyButton = document.getElementById('apply-button');
 	 	 	applyButton.disabled = true;
 	 	 	applyButton.textContent = 'Applying...';

 	 	 	fetch('/api/apply', {
 	 	 	 	method: 'POST',
 	 	 	 	headers: { 'Content-Type': 'application/json' },
 	 	 	 	body: JSON.stringify(selectedChanges)
 	 	 	})
 	 	 	 	.then(response => response.json())
 	 	 	 	.then(result => {
 	 	 	 	 	console.log('Apply result:', result);
 	 	 	 	 	alert('Operation complete! Check the server console for details. The page will now refresh.');
 	 	 	 	 	window.location.reload();
 	 	 	 	})
 	 	 	 	.catch(error => {
 	 	 	 	 	console.error('Error applying changes:', error);
 	 	 	 	 	alert('Failed to apply changes.');
 	 	 	 	 	applyButton.disabled = false;
 	 	 	 	 	updateUIText(allChangesData.mode);
 	 	 	 	});
 	 	}

 	 	function getLanguage(filename) {
 	 	 	const ext = filename.split('.').pop().toLowerCase();
 	 	 	const langMap = {
 	 	 	 	'py': 'python', 'js': 'javascript', 'ts': 'typescript', 'html': 'html',
 	 	 	 	'css': 'css', 'json': 'json', 'md': 'markdown', 'java': 'java',
 	 	 	 	'go': 'go', 'sh': 'shell', 'yml': 'yaml', 'yaml': 'yaml', 'rs': 'rust'
 	 	 	};
 	 	 	return langMap[ext] || 'plaintext';
 	 	}

 	</script>
</body>

</html>